<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java语言学习</title>
    <link href="/2025/08/java-base/"/>
    <url>/2025/08/java-base/</url>
    
    <content type="html"><![CDATA[<p>由浅入深介绍java语言中常用的基础语法，打好地基，写出优雅的代码。</p><span id="more"></span><h1 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h1><h1 id="Java等待全部子线程执行完毕"><a href="#Java等待全部子线程执行完毕" class="headerlink" title="Java等待全部子线程执行完毕"></a>Java等待全部子线程执行完毕</h1><p>使用CountDownLatch实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LatchExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadCount);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行中...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                latch.countDown(); <span class="hljs-comment">// 通知完成</span><br>            &#125;, <span class="hljs-string">&quot;子线程-&quot;</span> + i).start();<br>        &#125;<br><br>        latch.await(); <span class="hljs-comment">// 等待所有子线程完成</span><br>        System.out.println(<span class="hljs-string">&quot;所有子线程执行完毕，主线程继续&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubectl命令使用</title>
    <link href="/2025/08/how-to-use-kubectl/"/>
    <url>/2025/08/how-to-use-kubectl/</url>
    
    <content type="html"><![CDATA[<p>由浅入深介绍kubectl命令的使用，常用于服务器上的运维操作。</p><span id="more"></span><p>kubectl是k8s的命令行客户端，用于管理集群中各种资源。其中kubectl命令可以简写成 k。<br>K8s 资源对象也有简写（大小写不敏感）：</p><table><thead><tr><th>全称</th><th>简写</th></tr></thead><tbody><tr><td>pods</td><td>po</td></tr><tr><td>services</td><td>svc</td></tr><tr><td>namespaces</td><td>ns</td></tr><tr><td>nodes</td><td>no</td></tr><tr><td>deployments</td><td>deploy</td></tr><tr><td>replicasets</td><td>rs</td></tr><tr><td>daemonsets</td><td>ds</td></tr><tr><td>statefulsets</td><td>sts</td></tr><tr><td>configmaps</td><td>cm</td></tr><tr><td>secrets</td><td>secret</td></tr><tr><td>persistentvolume</td><td>pv</td></tr><tr><td>persistentvolumeclaim</td><td>pvc</td></tr><tr><td>endpoints</td><td>ep</td></tr><tr><td>jobs</td><td>job</td></tr><tr><td>cronjobs</td><td>cj</td></tr><tr><td>events</td><td>ev</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">k get po -n kube-system      <span class="hljs-comment"># 查看 kube-system 命名空间下的所有 Pod</span><br>k describe deploy myapp      <span class="hljs-comment"># 查看 myapp Deployment 详情</span><br></code></pre></td></tr></table></figure><h1 id="查看资源信息"><a href="#查看资源信息" class="headerlink" title="查看资源信息"></a>查看资源信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods              <span class="hljs-comment"># 查看当前命名空间的所有 Pod</span><br>kubectl get pods -n kube-system  <span class="hljs-comment"># 查看指定命名空间的 Pod</span><br>kubectl get svc               <span class="hljs-comment"># 查看 Service</span><br>kubectl get nodes             <span class="hljs-comment"># 查看集群节点</span><br>kubectl get deployments       <span class="hljs-comment"># 查看 Deployment</span><br>kubectl get ns                <span class="hljs-comment"># 查看所有命名空间</span><br>kubectl get pod &lt;pod-name&gt; -o wide  <span class="hljs-comment"># 显示更多信息（IP、节点等）</span><br>kubectl api-resources       <span class="hljs-comment"># 查看当前集群支持的资源类型</span><br></code></pre></td></tr></table></figure><p>若查看指定资源的yaml信息，可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get &lt;资源类型&gt; &lt;资源名称&gt; -o yaml<br><br>kubectl get pod my-pod -o yaml<br>kubectl get pods -o yaml<br>kubectl get deployment my-deploy -o yaml<br>kubectl get deploy my-deploy -o yaml &gt; my-deploy.yaml<br></code></pre></td></tr></table></figure><p>在 kubectl 里，-o 是 –output 的简写，用来指定输出的格式。</p><table><thead><tr><th>格式</th><th>用法示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>wide</strong></td><td><code>kubectl get pods -o wide</code></td><td>在表格模式下显示更多信息（节点名、IP 等）</td></tr><tr><td><strong>yaml</strong></td><td><code>kubectl get pod my-pod -o yaml</code></td><td>以 YAML 格式输出资源完整描述（适合阅读、导出）</td></tr><tr><td><strong>json</strong></td><td><code>kubectl get pod my-pod -o json</code></td><td>以 JSON 格式输出资源完整描述（适合脚本处理）</td></tr><tr><td><strong>name</strong></td><td><code>kubectl get pods -o name</code></td><td>只输出资源名称（便于脚本批量处理）</td></tr><tr><td><strong>jsonpath&#x3D;…</strong></td><td><code>kubectl get pods -o jsonpath=&#39;&#123;.items[*].metadata.name&#125;&#39;</code></td><td>用 JSONPath 表达式提取指定字段</td></tr><tr><td><strong>go-template</strong></td><td><code>kubectl get pods -o go-template=&#39;&#123;&#123;.metadata.name&#125;&#125;&#39;</code></td><td>使用 Go 模板格式化输出（高级用法）</td></tr></tbody></table><h1 id="修改yaml"><a href="#修改yaml" class="headerlink" title="修改yaml"></a>修改yaml</h1><p>可用通过<code>edit</code>命令修改deployment的yaml字段，修改image镜像的方式来实现黑屏变更。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">-n</span> <span class="hljs-string">kox</span> <span class="hljs-string">edit</span> <span class="hljs-string">cafedeployment</span> <span class="hljs-string">cd-name</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>kubectl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言学习</title>
    <link href="/2025/07/go-base/"/>
    <url>/2025/07/go-base/</url>
    
    <content type="html"><![CDATA[<p>由浅入深介绍go语言中常用的基础语法，打好地基，写出优雅的代码。</p><span id="more"></span><h1 id="go基本语法"><a href="#go基本语法" class="headerlink" title="go基本语法"></a>go基本语法</h1><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>go有两种字符类型：<strong>byte</strong>和<strong>rune</strong>。</p><p>byte代表字符串的一个字符，即ASCII编码中的一个字符。rune类型代表utf-8的一个字符。</p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>go提供指针类型进行访问，但不允许指针运算。go中的赋值属于拷贝复制，用指针类型可以提高性能，无需拷贝数据。</p><p>指针类型允许为nil，对象类型不允许为nil，会默认初始化为控对象。</p><p>使用new方法创建对象时会返回指针。</p><h2 id="Go语言模拟枚举（const和iota模拟枚举）"><a href="#Go语言模拟枚举（const和iota模拟枚举）" class="headerlink" title="Go语言模拟枚举（const和iota模拟枚举）"></a>Go语言模拟枚举（const和iota模拟枚举）</h2><p>go语言中没有<strong>enum</strong>类型，但可以使用const与iota模拟。</p><p>iota 是 Go 语言的常量计数器，在每一个 const 关键字出现时被重置为 0，并在每一行常量声明中自动递增。</p><h2 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h2><ul><li><p>数组是固定长度，对值进行拷贝赋值。</p></li><li><p>切片是长度可变，由指针、长度、容量三元组构成，每次赋值是拷贝切片结构体（底层数组未复制），相当于引用赋值。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    ptr unsafe.Pointer <span class="hljs-comment">// 指向底层数组的指针</span><br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>            <span class="hljs-comment">// 当前切片长度</span><br>    <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>            <span class="hljs-comment">// 当前切片容量</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片的扩容机制"><a href="#切片的扩容机制" class="headerlink" title="切片的扩容机制"></a>切片的扩容机制</h3><p>当使用 append() 向切片添加元素，超出当前容量时，Go 会自动进行扩容。扩容时，Go 会创建一个新的底层数组，并将原来的数据复制过去。</p><p>扩容策略（以 Go 1.21 为例）：</p><ul><li><p>当容量 &lt; 1024 时，每次扩容为原来的 2 倍。</p></li><li><p>当容量 ≥ 1024 时，扩容增长速度减缓，约为每次增加 1.25 倍。</p></li></ul><h2 id="sync-Map并发安全"><a href="#sync-Map并发安全" class="headerlink" title="sync.Map并发安全"></a>sync.Map并发安全</h2><p>sync.Map中的简要结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> &#123;<br>    mu Mutex<br><br>    read atomic.Value <span class="hljs-comment">// readOnly 结构（主要读）</span><br>    dirty <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]*entry <span class="hljs-comment">// 写或更新后才同步进 read</span><br>    misses <span class="hljs-type">int</span> <span class="hljs-comment">// 记录未命中次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现并发安全的原理：</p><ol><li>读操作<ul><li>首先访问 read（只读区），这部分通过 atomic.Value 保证并发读安全，不需要加锁。、</li><li>若命中，则直接返回。</li><li>若未命中，再去加锁访问 dirty（慢路径），同时 misses 计数加 1。</li></ul></li><li>写操作<ul><li>写操作（如 Store、Delete）都必须加锁，以确保多个写不冲突。</li><li>写入的键会放入 dirty，不会立即更新 read，只有当 misses 次数达到阈值时，才将 dirty 合并为新的 read。</li><li>这样避免了频繁写时都更新 read 带来的性能损耗。</li></ul></li><li>删除操作<ul><li>Delete 操作会先在 read 中标记删除（不是直接移除），dirty中的值会被加锁删除。</li><li>等到合并 dirty -&gt; read 时，才真正删除（称为懒惰删除）。读操作不加锁，如果直接删除 key，会导致其他 goroutine 的读操作可能读到无效数据或 panic（防止抛异常nil）。</li></ul></li></ol><h3 id="read为什么不直接删除？"><a href="#read为什么不直接删除？" class="headerlink" title="read为什么不直接删除？"></a>read为什么不直接删除？</h3><p>避免删除过程中，有其他goroutine读取，此时会读到nil抛异常。不直接删除是为了避免抛出异常。</p><h3 id="什么时候删除read？"><a href="#什么时候删除read？" class="headerlink" title="什么时候删除read？"></a>什么时候删除read？</h3><p>两种情况：</p><ol><li>map被更新了新值，需要把dirty传给read时，会把原来的read值真正删除。</li><li>多次读取被删除的值返回为空，读取不到的次数达到阈值会触发真正删除。</li></ol><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select用于处理多个channel操作的控制结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> val := &lt;-ch1:<br>    fmt.Println(<span class="hljs-string">&quot;Received&quot;</span>, val)<br><span class="hljs-keyword">case</span> ch2 &lt;- <span class="hljs-number">42</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Sent 42 to ch2&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    fmt.Println(<span class="hljs-string">&quot;No channel ready, executing default&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>若case语句中有多个条件成立，则随机选择一个进行执行。若都不满足，有default则执行default，否则一直阻塞直到有条件成立。</p><h1 id="go设置最大并发数"><a href="#go设置最大并发数" class="headerlink" title="go设置最大并发数"></a>go设置最大并发数</h1><p>通过直接设置环境变量 GOMAXPROCS 的值，或者在代码中启动 goroutine 之前先调用以下这个语句以设置使用 16 个 CPU 核心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">runtime.GOMAXPROCS(<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><h1 id="go竞态条件检测"><a href="#go竞态条件检测" class="headerlink" title="go竞态条件检测"></a>go竞态条件检测</h1><p>go语言提供了竞态条件检测工具，只需要在run或者build时加上 <code>-race</code> 参数即可启用检测:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>适用于 go run, go build, go test 命令。</p><p>当检测到竞态时，输出类似如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">==================<br><span class="hljs-symbol">WARNING:</span> DATA RACE<br>Write at <span class="hljs-number">0</span>x000000123456 <span class="hljs-keyword">by</span> goroutine <span class="hljs-number">6</span>:<br>  main.main.func1()<br>      /path/<span class="hljs-keyword">to</span>/main.go:<span class="hljs-number">10</span> +<span class="hljs-number">0</span>x34<br><br>Previous read at <span class="hljs-number">0</span>x000000123456 <span class="hljs-keyword">by</span> main goroutine:<br>  main.main()<br>      /path/<span class="hljs-keyword">to</span>/main.go:<span class="hljs-number">11</span> +<span class="hljs-number">0</span>x20<br>==================<br></code></pre></td></tr></table></figure><p>分析信息：</p><ul><li>哪个变量被竞态访问（地址）</li><li>哪些 goroutine 在什么时候、哪一行访问了它</li><li>哪些是写、哪些是读</li></ul><h1 id="go协程等待组"><a href="#go协程等待组" class="headerlink" title="go协程等待组"></a>go协程等待组</h1><p>除了使用channel实现wait功能外，go还额外提供了等待组：<code>sync.WaitGroup</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个等待组</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 每一个任务开始前, 将等待组增加1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 协程任务</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 任务完成后, 使用Done()将等待组值减1</span><br>    <span class="hljs-keyword">defer</span> wg.Done()<br>&#125;<br><span class="hljs-comment">// 等待所有的任务完成</span><br>wg.Wait()<br></code></pre></td></tr></table></figure><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>Go 从 1.5 版本开始引入了并发 GC，目前使用的是一种 非分代、三色标记-清除法 + 混合写屏障 的 并发垃圾回收器，具有以下特性：</p><ul><li>并发标记阶段：GC 线程和用户程序（mutator）并行运行</li><li>STW（Stop The World）时间短：只在小部分阶段暂停整个程序</li><li>非分代（non-generational）：不像 Java 那样区分新生代、老年代</li><li>精确 GC：内存布局可追踪，误标率低</li></ul><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>三种颜色的含义：</p><table><thead><tr><th>颜色</th><th>含义</th></tr></thead><tbody><tr><td>白色</td><td>尚未访问到的对象（可能被回收）</td></tr><tr><td>灰色</td><td>已访问的对象，但其引用的对象未全部访问</td></tr><tr><td>黑色</td><td>已访问，且其引用对象也已访问</td></tr></tbody></table><p>标记过程简述：</p><ol><li>初始状态：所有对象为白色。</li><li>从根对象（root set）出发，将其标记为灰色。</li><li>遍历灰色对象：<ul><li>标记为黑色；</li><li>将其引用的白色对象标记为灰色。</li></ul></li><li>重复步骤 3，直到灰色对象为空。</li><li>未变为黑色的白色对象即为垃圾，可以回收。</li></ol><h3 id="灰色存在的意义"><a href="#灰色存在的意义" class="headerlink" title="灰色存在的意义"></a>灰色存在的意义</h3><p>如果标记阶段是连续进行的，只有黑色和白色也能完成垃圾回收，但由于标记阶段是渐近的，需要通过灰色是否存在判断标记阶段是否完成，完成后才开始回收阶段。灰色存在的意义就是用来区分当前标记阶段是否完成。</p><h2 id="写屏障技术"><a href="#写屏障技术" class="headerlink" title="写屏障技术"></a>写屏障技术</h2><p>由于标记阶段是渐近的，可能在标记过程中引用关系会发生修改，导致对象被错误标记从而被错误回收。<br>因此，写屏障技术通过在对象引用字段赋值操作时插入特殊逻辑（即屏障代码），用来协助垃圾回收器追踪和维护堆对象之间的引用关系，让 GC 能感知这次写操作，并做出修正</p><h1 id="go语言的反射机制"><a href="#go语言的反射机制" class="headerlink" title="go语言的反射机制"></a>go语言的反射机制</h1>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s相关概念介绍</title>
    <link href="/2025/06/what-is-k8s/"/>
    <url>/2025/06/what-is-k8s/</url>
    
    <content type="html"><![CDATA[<p>k8s负责多个pod的部署与运维，由一系列<strong>Pod</strong>以及管理Pod的一系列<strong>工具</strong>组成。</p><span id="more"></span><h1 id="什么是Pod"><a href="#什么是Pod" class="headerlink" title="什么是Pod"></a>什么是Pod</h1><p>Pod是k8s中最小的可部署单元，一个Pod中包含多个容器，这些容器共享namespace、volume、声明周期，通常用于部署一个功能单元。</p><p>将一个功能切分成多个子功能部署到不同的容器中，这种模式叫做sidecar，Pod中的多个容器协同工作共同组成一个功能单元。</p><h2 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h2><p>为了确保Pod的状态始终符合预期，定义了 Pod控制器。Pod控制器中定义了Pod的副本数、生命周期、健康状态检查等等，用于安全稳定地创建、管理、维护Pod。</p><p><strong>在云原生应用中，一般不会直接去创建裸的Pod，而是通过Pod控制器去创建Pod，确保Pod生命周期地安全、稳定</strong>。</p><p>Pod控制器主要包括五大类：</p><ol><li>Deploymoent。用于管理一组无状态的Pod，这一组Pod通常是一个Pod的多个副本。这些Pod是无状态的，可以无序启动和关闭，系统会尽量保证副本数量，但没有顺序要求。这些Pod的IP和DNS是动态的，重启后会发生变化。</li><li>Stateful。用于管理一组有状态的Pod，这些Pod通常是一个Pod的多个副本，但这些副本之间定义了启动顺序，列入：数据库、消息队列。这些Pod的IP和DNS是固定的，重启后不会发生变化。</li><li>DemonSet。用于确保集群中每个服务器都会有一个Pod副本。</li><li>Job。用于管理一次性Pod，执行完后销毁。其副本数量相当于指明任务运行的次数。多用于脚本的管理。</li><li>CronJob。用于控制定时运行的Job。</li></ol><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>为了隔离不同类型的资源组，引入了命名空间（namespace）的概念。namespace可以理解为k8s内部的虚拟集群组，查询k8s内的资源需要指定namespace。</p><p>不同名称空间内的“资源”名称可以相同，相同名称空间内的同种“资源”、“名称”不能相同。</p><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>对于k8s中众多的资源，使用Label机制进行分类管理，Label由多个key-value键值对组成。</p><p>一个标签可以对应多个资源，一个资源也可以对应多个标签，他们是多对多的关系。</p><p>一个资源可以通过多个标签实现不同维度的管理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br></code></pre></td></tr></table></figure><p>例如：控制器（如 Deployment）不会直接绑定某个 Pod，而是根据标签选择 Pod。</p><p>工作流程示意：</p><ol><li><p>创建一个 Deployment，指定了 matchLabels: app&#x3D;nginx。</p></li><li><p>Deployment 控制器通过标签找到当前所有 app&#x3D;nginx 的 Pod。</p></li><li><p>根据期望副本数（replicas）对这些 Pod 进行增删改。</p></li></ol><p>标签最常用在Pod上，用于对Pod进行筛选，同时对于k8s中的其他资源，也可以用标签进行描述。</p><p>给资源打上标签后，可以使用标签选择器过滤指定的标签。<br>标签选择器目前有两个：基于等值关系（等于、不等于）和基于集合关系（属于、不属于、存在）。许多资源支持内嵌标签选择器字段</p><ul><li>matchLabels</li><li>matchExpressions</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>k8s中Pod本身的IP地址不是固定的，随着Pod的销毁和重建，其<strong>IP就会发生变化</strong>。<br>为了给Pod提供稳定的对外IP入口，引入了Service。</p><p>Service可以看作“网关”，对外提供稳定访问的虚拟IP+DNS名称，接收请求后路由转发至对应的Pod进行服务。转发的过程是通过<strong>Label Selector</strong>筛选到对应的Pod，避开了动态IP。</p><p>Pod控制器stateful也是通过service为Pod提供稳定的IP，确保Pod每次重建都会保留固定的IP和DNS。</p><p>Service共有5种类型：</p><ul><li>ClusterIP（默认类型），用于集群内部通信，会自动分配一个固定的虚拟 IP，该IP不能从集群外访问，适用于服务之间的内部通信。</li><li>NodePort，通过端暴露端口的方式可用于集群外访问的Service，给每个Node暴露一个端口，可通过<strong>NodeIP：NodePort</strong>进行访问。注意：Node是Cluster中的最小计算单元，一般是一个实际运行的机器，上面包含多个Pod。</li><li>LoadBalancer，在NodePort的基础上增加了一层负载均衡器，用于创建可负载均衡的对外访问的Service。</li><li>ExternalName，用于在集群内部访问外部服务，将集群内部主机名映射到外部服务的DNS稳定访问。</li><li>Headless Service，通常用于StatefulSet，不分配Cluster IP，直接暴露每个Pod的真实IP，然后通过DNS每次都指向该Pod，提供稳定的主机名访问，即IP不固定，但DNS主机名稳定。</li></ul><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>Ingress负责管理集群HTTP&#x2F;HTTPS路由规则的资源。与Service相比，Service侧重于IP+Port进行请求转发（TCP&#x2F;UDP），Ingress通过域名URL+Path进行请求转发（HTTP&#x2F;HTTPS）。</p><p>Ingress定义了路由规则，但不会自动生效，由Ingress Controller监听 Ingress 对象，由Ingress Controller根据Ingress定义的规则进行实际生效、执行路由转发。Ingress Controller会将请求转发给对应的Service，再由Service转发给对应的Pod进行执行。</p><h2 id="k8s整体架构"><a href="#k8s整体架构" class="headerlink" title="k8s整体架构"></a>k8s整体架构</h2><p>k8s的整体架构图如下所示：</p><img src="/2025/06/what-is-k8s/k8s%E7%BB%93%E6%9E%84%E5%9B%BE.jpeg" class="" title="k8s架构图"><p>下面根据外部请求打到k8s的整个路由过程，详细介绍一下k8s的整体架构及各个组件的作用：</p><ul><li>外部请求访问k8s服务时，请求优先打到Ingress Controller，根据Ingress定义的规则路由给对应的Service。</li><li>Kube-proxy：Kube-proxy是运行在每个Node上的网络代理组件，由该组件实现Service到Pod的路由转发及负载均衡，为Service提供cluster内部的服务发现和负载均衡。</li><li>kubelet: 运行在每个节点上，启动并管理的容器最终处理请求（拉取镜像、挂载卷、调用容器运行时，启动容器）。Pod控制器就是通过kubelet实现对Pod的控制（Pod控制器定义规则PodSpec并写入etcd，由kube-scheduler分配给具体的节点，在节点上由kubelet负责最终执行）。</li><li>etcd：是一个分布式的、高可用的键值数据库，采用 Raft 一致性算法 保证数据一致性，用于存储k8s中资源对象的配置和状态。</li><li>kube-scheduler：负责调度决策，负责将Pod调度给指定的节点，为集群中新建的、尚未分配节点的 Pod 选择最合适的节点。</li><li>api server：k8s的控制中枢，提供restful api接口的方式，调度k8s各个组件的协作与执行，也是唯一一个可以读写etcd的组件。</li><li>kubectl：是k8s官方提供的命令行工具，它发送http请求给api server，完成k8s的一系列管理运维操作。</li><li>Controller Manager: 负责管理各个资源类型的生命周期，包括Ingress Controller、ReplicaSet Controller、Deployment Controller、Service Controller等等，每种资源类型都会有对应的控制器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生资源类型</title>
    <link href="/2025/06/what-is-workload/"/>
    <url>/2025/06/what-is-workload/</url>
    
    <content type="html"><![CDATA[<p>介绍一下云原生资源中常见的几种资源类型。</p><span id="more"></span> <p>云原生资源类型：</p><ul><li>工作负载（Workload）资源</li><li>服务发现与负载均衡资源（Service &amp; Networking）</li><li>配置与存储资源（Configuration &amp; Storage）</li><li>身份与访问控制（Security &amp; RBAC）</li><li>调度与运行时资源（Scheduling &amp; Runtime）</li><li>集群元数据与控制资源（Meta &amp; Control）</li></ul><h2 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h2><p>workload是指运行在k8s集群上的应用程序实例，workload通常管理着一组Pod。</p><p>常见的 Workload 类型（以 Kubernetes 为例）：</p><ol><li><p>Pod<br>最基本的计算单元，通常包含一个或多个容器。</p></li><li><p>Deployment<br>用于管理无状态服务，支持自动扩缩容、滚动更新等。</p></li><li><p>StatefulSet<br>用于管理有状态服务，比如数据库，提供稳定的网络标识、存储等。</p></li><li><p>DaemonSet<br>保证每个（或指定）节点上运行一个 Pod，常用于日志收集、监控等。</p></li><li><p>Job<br>一次性任务，执行完成后退出，适用于批处理任务。</p></li><li><p>CronJob<br>类似于 Linux 的定时任务，定时运行 Job。</p></li></ol><p>Workload 的作用</p><ul><li><p>部署应用：你可以通过定义 Deployment 或 StatefulSet 来部署服务。</p></li><li><p>生命周期管理：自动控制副本数量、重启策略、滚动升级等。</p></li><li><p>解耦基础设施与应用：Workload 资源定义了“运行什么、怎么运行”，与底层节点、操作系统解耦。</p></li><li><p>可观测性和伸缩性：配合服务网格、监控工具和自动扩缩容机制，提高系统弹性。</p></li></ul><h2 id="ZPAAS-与-workload"><a href="#ZPAAS-与-workload" class="headerlink" title="ZPAAS 与 workload"></a>ZPAAS 与 workload</h2><p>蚂蚁集团在经典的部署资源叫做ZPAAS，以虚拟机为载体进行部署。</p><p>云原生概念出现后，应用部署转向为workload云原生资源。但是为了兼容已有的存量ZPAAS资源，在做应用发布时保留了ZPAAS发布、ZPAAS与workload混合发布。</p><p>在应用发布之前先判断应用所属的部署类型，然后在运行时通过SPI（service provider interface）调用对应的部署实现。</p>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2025/04/how-to-use-hexo/"/>
    <url>/2025/04/how-to-use-hexo/</url>
    
    <content type="html"><![CDATA[<p>介绍一下hexo使用过程中常用的指令。</p><span id="more"></span> <h1 id="如何使用hexo"><a href="#如何使用hexo" class="headerlink" title="如何使用hexo"></a>如何使用hexo</h1><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><ol><li>在默认目录source&#x2F;_post下创建文章。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post &lt;article name&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>在子目录下创建文章，使用-p参数，会在source&#x2F;_post下创建子目录dir。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post -p &lt;<span class="hljs-built_in">dir</span>/article name&gt;<br></code></pre></td></tr></table></figure><h2 id="创建草稿"><a href="#创建草稿" class="headerlink" title="创建草稿"></a>创建草稿</h2><ol><li>默认会在source&#x2F;_drafts目录下创建草稿。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h2><ol><li>直接将草稿中的文件移动到默认目录source&#x2F;_post下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="设置摘要"><a href="#设置摘要" class="headerlink" title="设置摘要"></a>设置摘要</h2><p>在摘要内容末尾添加标注<code>&lt;!-- more --&gt;</code>，会将该标志前面部分设置为摘要，后面的为正文。</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>需要把图片先存入文章的同名目录下，并使用asset_img命令在文章指定位置插入图片。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% asset_img 图片名称 图片标题 %&#125;<br></code></pre></td></tr></table></figure><h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><ol><li>在config文件中配置将hexo部署到github上，配置方法参考<a href="https://blog.csdn.net/yaorongke/article/details/119089190">文章</a>。</li><li>使用命令<code>hexo g -d</code>完成文章内容推送到GitHub上。g表示generate生成网页内容，d表示deploy部署，上述命令可以写成<code>hexo generate &amp;&amp; hexo deploy</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Docker</title>
    <link href="/2025/04/what-is-docker/"/>
    <url>/2025/04/what-is-docker/</url>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的轻量级容器平台，可以将应用及其依赖打包在Docker中，实现快速部署和跨环境运行。</p><span id="more"></span> <h1 id="Docker的核心组件"><a href="#Docker的核心组件" class="headerlink" title="Docker的核心组件"></a>Docker的核心组件</h1><p>Docker基于B&#x2F;S架构，其核心组件包括</p><ol><li>Docker Client</li><li>Docker Daemon</li><li>Docker Image</li><li>Docker Register</li><li>Docker Container</li></ol><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>用于发起各种请求，如<code>docker run</code>、<code>docker build</code>等等。最常用的 Docker 客户端就是 docker 命令和<a href="https://www.docker.com/products/docker-desktop/">docker desktop</a>。</p><h2 id="Dokcer-Deamon"><a href="#Dokcer-Deamon" class="headerlink" title="Dokcer Deamon"></a>Dokcer Deamon</h2><p>又称之为docker的核心进程，该进程会提供一个<strong>API Server</strong>（API Server是Deamon的一部分），负责接收来自docker client的请求，API Server 将通过Docker daemon 内部的一个<strong>路由</strong>分发调度，将请求路由到Daemon中对应的处理函数<strong>handler</strong>，handler再调用底层逻辑完成请求响应，并通过API Server返回响应。</p><p>Handler调用底层逻辑时，会交由处理引擎engine创建指定的job，job中绑定了具体的功能函数，完成处理逻辑。</p><p>Job 实际上是封装了对某个具体任务的调用。docker Daemon 启动时，会注册各种 Job：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/docker/docker/daemon/daemon.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> Install(eng *engine.Engine) <span class="hljs-type">error</span> &#123;<br>    eng.Register(<span class="hljs-string">&quot;create&quot;</span>, daemon.ContainerCreate)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler在运行时创建Job完成处理逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">job := eng.Job(<span class="hljs-string">&quot;create&quot;</span>, args...)<br><span class="hljs-keyword">if</span> err := job.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>docker deamon的结构可以分为三个部分：</p><ul><li>Docker Server，包括API Server、Router、Handler</li><li>Engine</li><li>Job</li></ul><p>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。 Docker Daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker Deamon的架构图如下所示：</p><img src="/2025/04/what-is-docker/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" class="" title="Docker架构图"><p>Job运行过程的作用有以下几种可能：</p><p>向 Docker Registry 获取镜像</p><ul><li>通过 graphdriver 执行容器镜像的本地化操作</li><li>通过 networkdriver 执行容器网络环境的配置</li><li>通过 execdriver 执行容器内部运行的执行工作</li></ul><h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</p><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 docker build &lt;docker-file&gt; 命令可以构建出 Docker 镜像。</p><h2 id="Docker-Register"><a href="#Docker-Register" class="headerlink" title="Docker Register"></a>Docker Register</h2><p>Docker registry 是存储 docker image 的仓库，运行docker push、docker pull、docker search时，实际上是通过 docker daemon 与 docker registry 通信。</p><h2 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h2><p>Container是Image运行的一个实例，是Image的运行时，是真正运行项目程序、消耗系统资源、提供服务的地方。</p><h1 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h1><p>Dockerfile是自动构建docker的配置文件，定义了docker image构建的流程。</p><h2 id="Dockerfile主要结构"><a href="#Dockerfile主要结构" class="headerlink" title="Dockerfile主要结构"></a>Dockerfile主要结构</h2><p>一般来说，一个dockerfile文件包含四个内容：</p><ol><li>基础镜像信息指令 FROM。</li><li>声明Image元信息（不只是创作者）的指令 LABEL.</li><li>镜像操作指令RUN 、 EVN 、 ADD 和 WORKDIR 等</li><li>镜像构建指令CMD 、 ENTRYPOINT 和 USER 等</li></ol><p>下面是一段简单的Dockerfile的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br><span class="hljs-keyword">MAINTAINER</span> qxp &lt;xiaopengqiu8@gmail.com&gt;<br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-comment"># 设置容器启动时执行的主程序为 python</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>] </span><br><span class="hljs-comment"># CMD 会作为参数传给 ENTRYPOINT，结合起来就是 python app.py</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>] </span><br></code></pre></td></tr></table></figure><h2 id="Dockerfile的常见命令"><a href="#Dockerfile的常见命令" class="headerlink" title="Dockerfile的常见命令"></a>Dockerfile的常见命令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>每个镜像都必须基于基础镜像构建，FROM 用于指定其父镜像。其中<code>FROM scratch</code>表示父镜像为空镜像，若不需要基于基础镜像构建，仍然需要用 FROM 进行指定。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>用于指定镜像的元数据，使用Key-Value标签，支持设定多个元数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;Angel_Kitty &lt;angelkitty6698@gmail.com&gt;&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;A cool Python app&quot;</span></span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>多次定义相同的 key，后面的会覆盖前面的</li></ul><h3 id="COPY、ADD"><a href="#COPY、ADD" class="headerlink" title="COPY、ADD"></a>COPY、ADD</h3><p>这两个命令都是将<strong>本地主机文件</strong>复制到指定<strong>容器</strong>中指定位置。<br>但ADD支持将压缩包<strong>自动解压</strong>以及<strong>远程下载</strong>文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hello.txt /app/hello.txt</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> app.tar.gz /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/file.zip /tmp/</span><br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置镜像的环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_ENV=prod<br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>设置构建镜像时的默认参数，设置后无需在build时用命令行传入参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> APP_VERSION=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>设置当前工作路径，相当于<code>cd</code>。WORKDIR可以设置多次，既可以用相对路径也可以用绝对路径。若使用相对路径，则这个相对路径是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> src</span><br></code></pre></td></tr></table></figure><p>最终的工作路径是<code>/root/app/src</code>。</p><p>注意事项：</p><ul><li>若使用相对路径，则是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>RUN用于容器内部执行命令（如安装依赖、编译项目等）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br></code></pre></td></tr></table></figure><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>用来指定对外开放的端口及协议。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/udp<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>EXPOSE只会暴露端口，但不会完成宿主机端口到容器端口的映射，需要在镜像<strong>运行</strong>时使用<code>docker run -p 5000:5000 myapp</code>完成。</li></ul><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>指定容器的固定启动任务，一个Dockerfile只能有一个ENTRYPOINT。配合CMD命令使用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD用于指明容器运行任务的默认参数，或作为备用的主命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>ENTRYPOINT与CMD都只能有一个，如果写了多个只会最后一个生效。</li></ul><h1 id="使用Dockerfile构建Docker"><a href="#使用Dockerfile构建Docker" class="headerlink" title="使用Dockerfile构建Docker"></a>使用Dockerfile构建Docker</h1><ol><li>构造dockerfile</li><li>使用build命令打包docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t &lt;镜像名&gt;:&lt;标签&gt; &lt;构建上下文路径&gt;<br>docker build -t myapp:1.0 .<br></code></pre></td></tr></table></figure><p>其中参数-t用于给镜像命名。<br>3. 使用run命令启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run &lt;镜像名&gt; --name &lt;容器名&gt; -d<br></code></pre></td></tr></table></figure><p>其中-name用于指定容器名，-d表示后台运行。</p><h1 id="容器是怎么隔离的"><a href="#容器是怎么隔离的" class="headerlink" title="容器是怎么隔离的"></a>容器是怎么隔离的</h1><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创建一个“边界”。</p><p>容器技术里进行隔离的两个核心技术：<strong>Cgroup</strong>技术和<strong>Namespace</strong>技术。</p><h2 id="Cgroup技术"><a href="#Cgroup技术" class="headerlink" title="Cgroup技术"></a>Cgroup技术</h2><p>其名源自<strong>控制组群（Control Group）<strong>的简写，是Linux内核的一个功能，通过</strong>追踪和限制</strong>进程组的资源使用情况，来限制、控制与分离一个<strong>进程组</strong>的资源（如CPU、内存、磁盘等）。</p><h2 id="Namespace技术"><a href="#Namespace技术" class="headerlink" title="Namespace技术"></a>Namespace技术</h2><p>Namespace是Linux内核的一种机制，通过在内核中为不同进程分配不同的<strong>资源视图</strong>来实现资源隔离。</p><p>通俗的来讲，Cgroup负责<strong>资源限制</strong>，限制容器能使用多少资源；Namespace负责<strong>资源隔离</strong>，让容器看不见“外面的世界”。</p><h1 id="Docker的镜像层"><a href="#Docker的镜像层" class="headerlink" title="Docker的镜像层"></a>Docker的镜像层</h1><p>Docker镜像实际上不是一个完整的压缩包，而是由一层层镜像层叠加而成的结构，每一层都是一个文件系统的变更记录，最终形成完整的可用镜像。</p><p>镜像层由Dockerfile中的<strong>每一条指令</strong>生成，比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span>        <span class="hljs-comment"># 创建基础层（Layer 1）</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update       <span class="hljs-comment"># 创建新的只读层（Layer 2）</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y python3 <span class="hljs-comment"># Layer 3</span></span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app              <span class="hljs-comment"># Layer 4</span></span><br></code></pre></td></tr></table></figure><p>镜像层的特点：</p><ul><li>每执行一条指令，就会生成一层</li><li>每一层都依赖于上一层</li><li>每一层都是不可变的，都是<strong>只读层</strong></li><li>如果中间的镜像层发生变化，Docker就会重建该层及以上的层。</li></ul><p>每一个镜像层本质上是一个文件快照系统（通常是一个.tar压缩包），它记录了该层：</p><ul><li>添加的文件</li><li>修改的文件</li><li>删除的文件</li></ul><p>使用镜像层的好处：</p><ol><li>分层缓存<br>Docker构建镜像时，如果某层的指令没变，它就会复用该层，避免重新构建。</li><li>高效存储<br>多个镜像可以共用相同的底层层（比如多个 Python 项目共用 ubuntu 基础层），节省磁盘空间。</li><li>快速分发<br>每一层都可以单独下载和上传，Docker Hub只需要同步变化的部分。</li></ol><h1 id="Docker的容器层"><a href="#Docker的容器层" class="headerlink" title="Docker的容器层"></a>Docker的容器层</h1><p>基于镜像构建容器时，就是在最外层增加一个<strong>可写层</strong>供动态编辑。<br>容器层主要负责：</p><ul><li>容器运行时的文件写入（如生成日志、缓存文件、应用运行时的临时数据）；</li><li>用户在容器内修改文件（如 echo hello &gt; file.txt）；<br>容器停止或删除，可写层会消失。若使用 <code>docker commit</code>将容器保存成新的镜像，就会把可写层也转化成镜像层。</li></ul><p>注意事项：</p><ul><li>Cgroup和Namespace都属于内核空间，与层无关，由进程加载对应的配置；镜像层、容器层都属于文件系统。</li></ul><h1 id="Docker的四种网络模式"><a href="#Docker的四种网络模式" class="headerlink" title="Docker的四种网络模式"></a>Docker的四种网络模式</h1><ul><li>host模式</li><li>container模式</li><li>none模式</li><li>bridge模式</li></ul><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><p>容器不会有独立的network namespace，而是和宿主机共用network namespace，使用宿主机的IP和端口，但是其他资源如文件系统、进程列表还是和宿主机隔离的。</p><ul><li>优点：网络性能号</li><li>缺点：没有网络隔离，可能存在端口冲突</li></ul><h2 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h2><p>指定新创建的容器和一个已有的容器共用一个network namespace。</p><ul><li>优点：可以实现进程隔离+网络共享</li><li>缺点：一个容器的网络故障会影响多个容器</li></ul><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>没有network container，完全禁用网络功能</p><ul><li>优点：网络安全，不会被攻击</li><li>缺点：无法访问外部，也无法被外部访问</li></ul><h2 id="bridge模式（默认）"><a href="#bridge模式（默认）" class="headerlink" title="bridge模式（默认）"></a>bridge模式（默认）</h2><p>bridge模式是<strong>默认</strong>的网络模式。容器有自己的network namespace，有自己NAT IP地址，通过虚拟网桥docker0与宿主机网络进行连接，由虚拟网桥转发网络请求（类似于NAT私有网络地址转换）。</p><ul><li>优点：网络隔离性好，各自拥有独立的端口</li><li>缺点：性能不如host模式（中间经过了一层转发）</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
