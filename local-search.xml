<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>k8s相关概念介绍</title>
    <link href="/2025/06/what-is-kube/"/>
    <url>/2025/06/what-is-kube/</url>
    
    <content type="html"><![CDATA[<p>k8s负责多个pod的部署与运维，由一系列<strong>Pod</strong>以及管理Pod的一系列<strong>工具</strong>组成。</p><span id="more"></span><h1 id="什么是Pod"><a href="#什么是Pod" class="headerlink" title="什么是Pod"></a>什么是Pod</h1><p>Pod是k8s中最小的可部署单元，一个Pod中包含多个容器，这些容器共享namespace、volume、声明周期，通常用于部署一个功能单元。</p><p>将一个功能切分成多个子功能部署到不同的容器中，这种模式叫做sidecar，Pod中的多个容器协同工作共同组成一个功能单元。</p><h2 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h2><p>为了确保Pod的状态始终符合预期，定义了 Pod控制器。Pod控制器中定义了Pod的副本数、生命周期、健康状态检查等等，用于安全稳定地创建、管理、维护Pod。</p><p><strong>在云原生应用中，一般不会直接去创建裸的Pod，而是通过Pod控制器去创建Pod，确保Pod生命周期地安全、稳定</strong>。</p><p>Pod控制器主要包括五大类：</p><ol><li>Deploymoent。用于管理一组无状态的Pod，这一组Pod通常是一个Pod的多个副本。这些Pod是无状态的，可以无序启动和关闭，系统会尽量保证副本数量，但没有顺序要求。这些Pod的IP和DNS是动态的，重启后会发生变化。</li><li>Stateful。用于管理一组有状态的Pod，这些Pod通常是一个Pod的多个副本，但这些副本之间定义了启动顺序，列入：数据库、消息队列。这些Pod的IP和DNS是固定的，重启后不会发生变化。</li><li>DemonSet。用于确保集群中每个服务器都会有一个Pod副本。</li><li>Job。用于管理一次性Pod，执行完后销毁。其副本数量相当于指明任务运行的次数。多用于脚本的管理。</li><li>CronJob。用于控制定时运行的Job。</li></ol><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>为了隔离不同类型的资源组，引入了命名空间（namespace）的概念。namespace可以理解为k8s内部的虚拟集群组，查询k8s内的资源需要指定namespace。</p><p>不同名称空间内的“资源”名称可以相同，相同名称空间内的同种“资源”、“名称”不能相同。</p><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>对于k8s中众多的资源，使用Label机制进行分类管理，Label由多个key-value键值对组成。</p><p>一个标签可以对应多个资源，一个资源也可以对应多个标签，他们是多对多的关系。</p><p>一个资源可以通过多个标签实现不同维度的管理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br></code></pre></td></tr></table></figure><p>例如：控制器（如 Deployment）不会直接绑定某个 Pod，而是根据标签选择 Pod。</p><p>工作流程示意：</p><ol><li><p>创建一个 Deployment，指定了 matchLabels: app&#x3D;nginx。</p></li><li><p>Deployment 控制器通过标签找到当前所有 app&#x3D;nginx 的 Pod。</p></li><li><p>根据期望副本数（replicas）对这些 Pod 进行增删改。</p></li></ol><p>标签最常用在Pod上，用于对Pod进行筛选，同时对于k8s中的其他资源，也可以用标签进行描述。</p><p>给资源打上标签后，可以使用标签选择器过滤指定的标签。<br>标签选择器目前有两个：基于等值关系（等于、不等于）和基于集合关系（属于、不属于、存在）。许多资源支持内嵌标签选择器字段</p><ul><li>matchLabels</li><li>matchExpressions</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>k8s中Pod本身的IP地址不是固定的，随着Pod的销毁和重建，其<strong>IP就会发生变化</strong>。<br>为了给Pod提供稳定的对外IP入口，引入了Service。</p><p>Service可以看作“网关”，对外提供稳定访问的虚拟IP+DNS名称，接收请求后路由转发至对应的Pod进行服务。转发的过程是通过<strong>Label Selector</strong>筛选到对应的Pod，避开了动态IP。</p><p>Pod控制器stateful也是通过service为Pod提供稳定的IP，确保Pod每次重建都会保留固定的IP和DNS。</p><p>Service共有5种类型：</p><ul><li>ClusterIP（默认类型），用于集群内部通信，会自动分配一个固定的虚拟 IP，该IP不能从集群外访问，适用于服务之间的内部通信。</li><li>NodePort，通过端暴露端口的方式可用于集群外访问的Service，给每个Node暴露一个端口，可通过<strong>NodeIP：NodePort</strong>进行访问。注意：Node是Cluster中的最小计算单元，一般是一个实际运行的机器，上面包含多个Pod。</li><li>LoadBalancer，在NodePort的基础上增加了一层负载均衡器，用于创建可负载均衡的对外访问的Service。</li><li>ExternalName，用于在集群内部访问外部服务，将集群内部主机名映射到外部服务的DNS稳定访问。</li><li>Headless Service，通常用于StatefulSet，不分配Cluster IP，直接暴露每个Pod的真实IP，然后通过DNS每次都指向该Pod，提供稳定的主机名访问，即IP不固定，但DNS主机名稳定。</li></ul><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>Ingress负责管理集群HTTP&#x2F;HTTPS路由规则的资源。与Service相比，Service侧重于IP+Port进行请求转发（TCP&#x2F;UDP），Ingress通过域名URL+Path进行请求转发（HTTP&#x2F;HTTPS）。</p><p>Ingress定义了路由规则，但不会自动生效，由Ingress Controller监听 Ingress 对象，由Ingress Controller根据Ingress定义的规则进行实际生效、执行路由转发。Ingress Controller会将请求转发给对应的Service，再由Service转发给对应的Pod进行执行。</p><h2 id="k8s整体架构"><a href="#k8s整体架构" class="headerlink" title="k8s整体架构"></a>k8s整体架构</h2><p>k8s的整体架构图如下所示：</p><p>下面根据外部请求打到k8s的整个路由过程，详细介绍一下k8s的整体架构及各个组件的作用：</p><ul><li>外部请求访问k8s服务时，请求优先打到Ingress Controller，根据Ingress定义的规则路由给对应的Service。</li><li>Kube-proxy：Kube-proxy是运行在每个Node上的网络代理组件，由该组件实现Service到Pod的路由转发及负载均衡。</li><li>kubelet</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生资源类型</title>
    <link href="/2025/06/what-is-workload/"/>
    <url>/2025/06/what-is-workload/</url>
    
    <content type="html"><![CDATA[<p>介绍一下云原生资源中常见的几种资源类型。</p><span id="more"></span> <p>云原生资源类型：</p><ul><li>工作负载（Workload）资源</li><li>服务发现与负载均衡资源（Service &amp; Networking）</li><li>配置与存储资源（Configuration &amp; Storage）</li><li>身份与访问控制（Security &amp; RBAC）</li><li>调度与运行时资源（Scheduling &amp; Runtime）</li><li>集群元数据与控制资源（Meta &amp; Control）</li></ul><h2 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h2><p>workload是指运行在k8s集群上的应用程序实例，workload通常管理着一组Pod。</p><p>常见的 Workload 类型（以 Kubernetes 为例）：</p><ol><li><p>Pod<br>最基本的计算单元，通常包含一个或多个容器。</p></li><li><p>Deployment<br>用于管理无状态服务，支持自动扩缩容、滚动更新等。</p></li><li><p>StatefulSet<br>用于管理有状态服务，比如数据库，提供稳定的网络标识、存储等。</p></li><li><p>DaemonSet<br>保证每个（或指定）节点上运行一个 Pod，常用于日志收集、监控等。</p></li><li><p>Job<br>一次性任务，执行完成后退出，适用于批处理任务。</p></li><li><p>CronJob<br>类似于 Linux 的定时任务，定时运行 Job。</p></li></ol><p>Workload 的作用</p><ul><li><p>部署应用：你可以通过定义 Deployment 或 StatefulSet 来部署服务。</p></li><li><p>生命周期管理：自动控制副本数量、重启策略、滚动升级等。</p></li><li><p>解耦基础设施与应用：Workload 资源定义了“运行什么、怎么运行”，与底层节点、操作系统解耦。</p></li><li><p>可观测性和伸缩性：配合服务网格、监控工具和自动扩缩容机制，提高系统弹性。</p></li></ul><h2 id="ZPAAS-与-workload"><a href="#ZPAAS-与-workload" class="headerlink" title="ZPAAS 与 workload"></a>ZPAAS 与 workload</h2><p>蚂蚁集团在经典的部署资源叫做ZPAAS，以虚拟机为载体进行部署。</p><p>云原生概念出现后，应用部署转向为workload云原生资源。但是为了兼容已有的存量ZPAAS资源，在做应用发布时保留了ZPAAS发布、ZPAAS与workload混合发布。</p><p>在应用发布之前先判断应用所属的部署类型，然后在运行时通过SPI（service provider interface）调用对应的部署实现。</p>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2025/04/how-to-use-hexo/"/>
    <url>/2025/04/how-to-use-hexo/</url>
    
    <content type="html"><![CDATA[<p>介绍一下hexo使用过程中常用的指令。</p><span id="more"></span> <h1 id="如何使用hexo"><a href="#如何使用hexo" class="headerlink" title="如何使用hexo"></a>如何使用hexo</h1><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><ol><li>在默认目录source&#x2F;_post下创建文章。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post &lt;article name&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>在子目录下创建文章，使用-p参数，会在source&#x2F;_post下创建子目录dir。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post -p &lt;<span class="hljs-built_in">dir</span>/article name&gt;<br></code></pre></td></tr></table></figure><h2 id="创建草稿"><a href="#创建草稿" class="headerlink" title="创建草稿"></a>创建草稿</h2><ol><li>默认会在source&#x2F;_drafts目录下创建草稿。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h2><ol><li>直接将草稿中的文件移动到默认目录source&#x2F;_post下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="设置摘要"><a href="#设置摘要" class="headerlink" title="设置摘要"></a>设置摘要</h2><p>在摘要内容末尾添加标注<code>&lt;!-- more --&gt;</code>，会将该标志前面部分设置为摘要，后面的为正文。</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>需要把图片先存入文章的同名目录下，并使用asset_img命令在文章指定位置插入图片。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% asset_img 图片名称 图片标题 %&#125;<br></code></pre></td></tr></table></figure><h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><ol><li>在config文件中配置将hexo部署到github上，配置方法参考<a href="https://blog.csdn.net/yaorongke/article/details/119089190">文章</a>。</li><li>使用命令<code>hexo g -d</code>完成文章内容推送到GitHub上。g表示generate生成网页内容，d表示deploy部署，上述命令可以写成<code>hexo generate &amp;&amp; hexo deploy</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Docker</title>
    <link href="/2025/04/what-is-docker/"/>
    <url>/2025/04/what-is-docker/</url>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的轻量级容器平台，可以将应用及其依赖打包在Docker中，实现快速部署和跨环境运行。</p><span id="more"></span> <h1 id="Docker的核心组件"><a href="#Docker的核心组件" class="headerlink" title="Docker的核心组件"></a>Docker的核心组件</h1><p>Docker基于B&#x2F;S架构，其核心组件包括</p><ol><li>Docker Client</li><li>Docker Daemon</li><li>Docker Image</li><li>Docker Register</li><li>Docker Container</li></ol><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>用于发起各种请求，如<code>docker run</code>、<code>docker build</code>等等。最常用的 Docker 客户端就是 docker 命令和<a href="https://www.docker.com/products/docker-desktop/">docker desktop</a>。</p><h2 id="Dokcer-Deamon"><a href="#Dokcer-Deamon" class="headerlink" title="Dokcer Deamon"></a>Dokcer Deamon</h2><p>又称之为docker的核心进程，该进程会提供一个<strong>API Server</strong>（API Server是Deamon的一部分），负责接收来自docker client的请求，API Server 将通过Docker daemon 内部的一个<strong>路由</strong>分发调度，将请求路由到Daemon中对应的处理函数<strong>handler</strong>，handler再调用底层逻辑完成请求响应，并通过API Server返回响应。</p><p>Handler调用底层逻辑时，会交由处理引擎engine创建指定的job，job中绑定了具体的功能函数，完成处理逻辑。</p><p>Job 实际上是封装了对某个具体任务的调用。docker Daemon 启动时，会注册各种 Job：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/docker/docker/daemon/daemon.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> Install(eng *engine.Engine) <span class="hljs-type">error</span> &#123;<br>    eng.Register(<span class="hljs-string">&quot;create&quot;</span>, daemon.ContainerCreate)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler在运行时创建Job完成处理逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">job := eng.Job(<span class="hljs-string">&quot;create&quot;</span>, args...)<br><span class="hljs-keyword">if</span> err := job.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>docker deamon的结构可以分为三个部分：</p><ul><li>Docker Server，包括API Server、Router、Handler</li><li>Engine</li><li>Job</li></ul><p>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。 Docker Daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker Deamon的架构图如下所示：</p><img src="/2025/04/what-is-docker/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" class="" title="Docker架构图"><p>Job运行过程的作用有以下几种可能：</p><p>向 Docker Registry 获取镜像</p><ul><li>通过 graphdriver 执行容器镜像的本地化操作</li><li>通过 networkdriver 执行容器网络环境的配置</li><li>通过 execdriver 执行容器内部运行的执行工作</li></ul><h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</p><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 docker build &lt;docker-file&gt; 命令可以构建出 Docker 镜像。</p><h2 id="Docker-Register"><a href="#Docker-Register" class="headerlink" title="Docker Register"></a>Docker Register</h2><p>Docker registry 是存储 docker image 的仓库，运行docker push、docker pull、docker search时，实际上是通过 docker daemon 与 docker registry 通信。</p><h2 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h2><p>Container是Image运行的一个实例，是Image的运行时，是真正运行项目程序、消耗系统资源、提供服务的地方。</p><h1 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h1><p>Dockerfile是自动构建docker的配置文件，定义了docker image构建的流程。</p><h2 id="Dockerfile主要结构"><a href="#Dockerfile主要结构" class="headerlink" title="Dockerfile主要结构"></a>Dockerfile主要结构</h2><p>一般来说，一个dockerfile文件包含四个内容：</p><ol><li>基础镜像信息指令 FROM。</li><li>声明Image元信息（不只是创作者）的指令 LABEL.</li><li>镜像操作指令RUN 、 EVN 、 ADD 和 WORKDIR 等</li><li>镜像构建指令CMD 、 ENTRYPOINT 和 USER 等</li></ol><p>下面是一段简单的Dockerfile的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br><span class="hljs-keyword">MAINTAINER</span> qxp &lt;xiaopengqiu8@gmail.com&gt;<br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-comment"># 设置容器启动时执行的主程序为 python</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>] </span><br><span class="hljs-comment"># CMD 会作为参数传给 ENTRYPOINT，结合起来就是 python app.py</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>] </span><br></code></pre></td></tr></table></figure><h2 id="Dockerfile的常见命令"><a href="#Dockerfile的常见命令" class="headerlink" title="Dockerfile的常见命令"></a>Dockerfile的常见命令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>每个镜像都必须基于基础镜像构建，FROM 用于指定其父镜像。其中<code>FROM scratch</code>表示父镜像为空镜像，若不需要基于基础镜像构建，仍然需要用 FROM 进行指定。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>用于指定镜像的元数据，使用Key-Value标签，支持设定多个元数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;Angel_Kitty &lt;angelkitty6698@gmail.com&gt;&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;A cool Python app&quot;</span></span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>多次定义相同的 key，后面的会覆盖前面的</li></ul><h3 id="COPY、ADD"><a href="#COPY、ADD" class="headerlink" title="COPY、ADD"></a>COPY、ADD</h3><p>这两个命令都是将<strong>本地主机文件</strong>复制到指定<strong>容器</strong>中指定位置。<br>但ADD支持将压缩包<strong>自动解压</strong>以及<strong>远程下载</strong>文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hello.txt /app/hello.txt</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> app.tar.gz /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/file.zip /tmp/</span><br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置镜像的环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_ENV=prod<br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>设置构建镜像时的默认参数，设置后无需在build时用命令行传入参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> APP_VERSION=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>设置当前工作路径，相当于<code>cd</code>。WORKDIR可以设置多次，既可以用相对路径也可以用绝对路径。若使用相对路径，则这个相对路径是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> src</span><br></code></pre></td></tr></table></figure><p>最终的工作路径是<code>/root/app/src</code>。</p><p>注意事项：</p><ul><li>若使用相对路径，则是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>RUN用于容器内部执行命令（如安装依赖、编译项目等）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br></code></pre></td></tr></table></figure><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>用来指定对外开放的端口及协议。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/udp<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>EXPOSE只会暴露端口，但不会完成宿主机端口到容器端口的映射，需要在镜像<strong>运行</strong>时使用<code>docker run -p 5000:5000 myapp</code>完成。</li></ul><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>指定容器的固定启动任务，一个Dockerfile只能有一个ENTRYPOINT。配合CMD命令使用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD用于指明容器运行任务的默认参数，或作为备用的主命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>ENTRYPOINT与CMD都只能有一个，如果写了多个只会最后一个生效。</li></ul><h1 id="使用Dockerfile构建Docker"><a href="#使用Dockerfile构建Docker" class="headerlink" title="使用Dockerfile构建Docker"></a>使用Dockerfile构建Docker</h1><ol><li>构造dockerfile</li><li>使用build命令打包docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t &lt;镜像名&gt;:&lt;标签&gt; &lt;构建上下文路径&gt;<br>docker build -t myapp:1.0 .<br></code></pre></td></tr></table></figure><p>其中参数-t用于给镜像命名。<br>3. 使用run命令启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run &lt;镜像名&gt; --name &lt;容器名&gt; -d<br></code></pre></td></tr></table></figure><p>其中-name用于指定容器名，-d表示后台运行。</p><h1 id="容器是怎么隔离的"><a href="#容器是怎么隔离的" class="headerlink" title="容器是怎么隔离的"></a>容器是怎么隔离的</h1><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创建一个“边界”。</p><p>容器技术里进行隔离的两个核心技术：<strong>Cgroup</strong>技术和<strong>Namespace</strong>技术。</p><h2 id="Cgroup技术"><a href="#Cgroup技术" class="headerlink" title="Cgroup技术"></a>Cgroup技术</h2><p>其名源自<strong>控制组群（Control Group）<strong>的简写，是Linux内核的一个功能，通过</strong>追踪和限制</strong>进程组的资源使用情况，来限制、控制与分离一个<strong>进程组</strong>的资源（如CPU、内存、磁盘等）。</p><h2 id="Namespace技术"><a href="#Namespace技术" class="headerlink" title="Namespace技术"></a>Namespace技术</h2><p>Namespace是Linux内核的一种机制，通过在内核中为不同进程分配不同的<strong>资源视图</strong>来实现资源隔离。</p><p>通俗的来讲，Cgroup负责<strong>资源限制</strong>，限制容器能使用多少资源；Namespace负责<strong>资源隔离</strong>，让容器看不见“外面的世界”。</p><h1 id="Docker的镜像层"><a href="#Docker的镜像层" class="headerlink" title="Docker的镜像层"></a>Docker的镜像层</h1><p>Docker镜像实际上不是一个完整的压缩包，而是由一层层镜像层叠加而成的结构，每一层都是一个文件系统的变更记录，最终形成完整的可用镜像。</p><p>镜像层由Dockerfile中的<strong>每一条指令</strong>生成，比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span>        <span class="hljs-comment"># 创建基础层（Layer 1）</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update       <span class="hljs-comment"># 创建新的只读层（Layer 2）</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y python3 <span class="hljs-comment"># Layer 3</span></span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app              <span class="hljs-comment"># Layer 4</span></span><br></code></pre></td></tr></table></figure><p>镜像层的特点：</p><ul><li>每执行一条指令，就会生成一层</li><li>每一层都依赖于上一层</li><li>每一层都是不可变的，都是<strong>只读层</strong></li><li>如果中间的镜像层发生变化，Docker就会重建该层及以上的层。</li></ul><p>每一个镜像层本质上是一个文件快照系统（通常是一个.tar压缩包），它记录了该层：</p><ul><li>添加的文件</li><li>修改的文件</li><li>删除的文件</li></ul><p>使用镜像层的好处：</p><ol><li>分层缓存<br>Docker构建镜像时，如果某层的指令没变，它就会复用该层，避免重新构建。</li><li>高效存储<br>多个镜像可以共用相同的底层层（比如多个 Python 项目共用 ubuntu 基础层），节省磁盘空间。</li><li>快速分发<br>每一层都可以单独下载和上传，Docker Hub只需要同步变化的部分。</li></ol><h1 id="Docker的容器层"><a href="#Docker的容器层" class="headerlink" title="Docker的容器层"></a>Docker的容器层</h1><p>基于镜像构建容器时，就是在最外层增加一个<strong>可写层</strong>供动态编辑。<br>容器层主要负责：</p><ul><li>容器运行时的文件写入（如生成日志、缓存文件、应用运行时的临时数据）；</li><li>用户在容器内修改文件（如 echo hello &gt; file.txt）；<br>容器停止或删除，可写层会消失。若使用 <code>docker commit</code>将容器保存成新的镜像，就会把可写层也转化成镜像层。</li></ul><p>注意事项：</p><ul><li>Cgroup和Namespace都属于内核空间，与层无关，由进程加载对应的配置；镜像层、容器层都属于文件系统。</li></ul><h1 id="Docker的四种网络模式"><a href="#Docker的四种网络模式" class="headerlink" title="Docker的四种网络模式"></a>Docker的四种网络模式</h1><ul><li>host模式</li><li>container模式</li><li>none模式</li><li>bridge模式</li></ul><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><p>容器不会有独立的network namespace，而是和宿主机共用network namespace，使用宿主机的IP和端口，但是其他资源如文件系统、进程列表还是和宿主机隔离的。</p><ul><li>优点：网络性能号</li><li>缺点：没有网络隔离，可能存在端口冲突</li></ul><h2 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h2><p>指定新创建的容器和一个已有的容器共用一个network namespace。</p><ul><li>优点：可以实现进程隔离+网络共享</li><li>缺点：一个容器的网络故障会影响多个容器</li></ul><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>没有network container，完全禁用网络功能</p><ul><li>优点：网络安全，不会被攻击</li><li>缺点：无法访问外部，也无法被外部访问</li></ul><h2 id="bridge模式（默认）"><a href="#bridge模式（默认）" class="headerlink" title="bridge模式（默认）"></a>bridge模式（默认）</h2><p>bridge模式是<strong>默认</strong>的网络模式。容器有自己的network namespace，有自己NAT IP地址，通过虚拟网桥docker0与宿主机网络进行连接，由虚拟网桥转发网络请求（类似于NAT私有网络地址转换）。</p><ul><li>优点：网络隔离性好，各自拥有独立的端口</li><li>缺点：性能不如host模式（中间经过了一层转发）</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
