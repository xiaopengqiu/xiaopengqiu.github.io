<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2025/04/how-to-use-hexo/"/>
    <url>/2025/04/how-to-use-hexo/</url>
    
    <content type="html"><![CDATA[<p>介绍一下hexo使用过程中常用的指令。</p><span id="more"></span> <h1 id="如何使用hexo"><a href="#如何使用hexo" class="headerlink" title="如何使用hexo"></a>如何使用hexo</h1><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><ol><li>在默认目录source&#x2F;_post下创建文章。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post &lt;article name&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>在子目录下创建文章，使用-p参数，会在source&#x2F;_post下创建子目录dir。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post -p &lt;<span class="hljs-built_in">dir</span>/article name&gt;<br></code></pre></td></tr></table></figure><h2 id="创建草稿"><a href="#创建草稿" class="headerlink" title="创建草稿"></a>创建草稿</h2><ol><li>默认会在source&#x2F;_drafts目录下创建草稿。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h2><ol><li>直接将草稿中的文件移动到默认目录source&#x2F;_post下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="设置摘要"><a href="#设置摘要" class="headerlink" title="设置摘要"></a>设置摘要</h2><p>在摘要内容末尾添加标注<code>&lt;!-- more --&gt;</code>，会将该标志前面部分设置为摘要，后面的为正文。</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>需要把图片先存入文章的同名目录下，并使用asset_img命令在文章指定位置插入图片。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% asset_img 图片名称 图片标题 %&#125;<br></code></pre></td></tr></table></figure><h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><ol><li>在config文件中配置将hexo部署到github上，配置方法参考<a href="https://blog.csdn.net/yaorongke/article/details/119089190">文章</a>。</li><li>使用命令<code>hexo g -d</code>完成文章内容推送到GitHub上。g表示generate生成网页内容，d表示deploy部署，上述命令可以写成<code>hexo generate &amp;&amp; hexo deploy</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Docker</title>
    <link href="/2025/04/what-is-docker/"/>
    <url>/2025/04/what-is-docker/</url>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的轻量级容器平台，可以将应用及其依赖打包在Docker中，实现快速部署和跨环境运行。</p><span id="more"></span> <h1 id="Docker的核心组件"><a href="#Docker的核心组件" class="headerlink" title="Docker的核心组件"></a>Docker的核心组件</h1><p>Docker基于B&#x2F;S架构，其核心组件包括</p><ol><li>Docker Client</li><li>Docker Daemon</li><li>Docker Image</li><li>Docker Register</li><li>Docker Container</li></ol><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>用于发起各种请求，如<code>docker run</code>、<code>docker build</code>等等。最常用的 Docker 客户端就是 docker 命令和<a href="https://www.docker.com/products/docker-desktop/">docker desktop</a>。</p><h2 id="Dokcer-Deamon"><a href="#Dokcer-Deamon" class="headerlink" title="Dokcer Deamon"></a>Dokcer Deamon</h2><p>又称之为docker的核心进程，该进程会提供一个<strong>API Server</strong>（API Server是Deamon的一部分），负责接收来自docker client的请求，API Server 将通过Docker daemon 内部的一个<strong>路由</strong>分发调度，将请求路由到Daemon中对应的处理函数<strong>handler</strong>，handler再调用底层逻辑完成请求响应，并通过API Server返回响应。</p><p>Handler调用底层逻辑时，会交由处理引擎engine创建指定的job，job中绑定了具体的功能函数，完成处理逻辑。</p><p>Job 实际上是封装了对某个具体任务的调用。docker Daemon 启动时，会注册各种 Job：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/docker/docker/daemon/daemon.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> Install(eng *engine.Engine) <span class="hljs-type">error</span> &#123;<br>    eng.Register(<span class="hljs-string">&quot;create&quot;</span>, daemon.ContainerCreate)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler在运行时创建Job完成处理逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">job := eng.Job(<span class="hljs-string">&quot;create&quot;</span>, args...)<br><span class="hljs-keyword">if</span> err := job.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>docker deamon的结构可以分为三个部分：</p><ul><li>Docker Server，包括API Server、Router、Handler</li><li>Engine</li><li>Job</li></ul><p>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。 Docker Daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker Deamon的架构图如下所示：</p><img src="/2025/04/what-is-docker/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" class="" title="Docker架构图"><p>Job运行过程的作用有以下几种可能：</p><p>向 Docker Registry 获取镜像</p><ul><li>通过 graphdriver 执行容器镜像的本地化操作</li><li>通过 networkdriver 执行容器网络环境的配置</li><li>通过 execdriver 执行容器内部运行的执行工作</li></ul><h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</p><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 docker build &lt;docker-file&gt; 命令可以构建出 Docker 镜像。</p><h2 id="Docker-Register"><a href="#Docker-Register" class="headerlink" title="Docker Register"></a>Docker Register</h2><p>Docker registry 是存储 docker image 的仓库，运行docker push、docker pull、docker search时，实际上是通过 docker daemon 与 docker registry 通信。</p><h2 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h2><p>Container是Image运行的一个实例，是Image的运行时，是真正运行项目程序、消耗系统资源、提供服务的地方。</p><h1 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h1><p>Dockerfile是自动构建docker的配置文件，定义了docker image构建的流程。</p><h2 id="Dockerfile主要结构"><a href="#Dockerfile主要结构" class="headerlink" title="Dockerfile主要结构"></a>Dockerfile主要结构</h2><p>一般来说，一个dockerfile文件包含四个内容：</p><ol><li>基础镜像信息指令 FROM。</li><li>声明Image元信息（不只是创作者）的指令 LABEL.</li><li>镜像操作指令RUN 、 EVN 、 ADD 和 WORKDIR 等</li><li>镜像构建指令CMD 、 ENTRYPOINT 和 USER 等</li></ol><p>下面是一段简单的Dockerfile的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br><span class="hljs-keyword">MAINTAINER</span> qxp &lt;xiaopengqiu8@gmail.com&gt;<br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-comment"># 设置容器启动时执行的主程序为 python</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>] </span><br><span class="hljs-comment"># CMD 会作为参数传给 ENTRYPOINT，结合起来就是 python app.py</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>] </span><br></code></pre></td></tr></table></figure><h2 id="Dockerfile的常见命令"><a href="#Dockerfile的常见命令" class="headerlink" title="Dockerfile的常见命令"></a>Dockerfile的常见命令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>每个镜像都必须基于基础镜像构建，FROM 用于指定其父镜像。其中<code>FROM scratch</code>表示父镜像为空镜像，若不需要基于基础镜像构建，仍然需要用 FROM 进行指定。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>用于指定镜像的元数据，使用Key-Value标签，支持设定多个元数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;Angel_Kitty &lt;angelkitty6698@gmail.com&gt;&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;A cool Python app&quot;</span></span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>多次定义相同的 key，后面的会覆盖前面的</li></ul><h3 id="COPY、ADD"><a href="#COPY、ADD" class="headerlink" title="COPY、ADD"></a>COPY、ADD</h3><p>这两个命令都是将<strong>本地主机文件</strong>复制到指定<strong>容器</strong>中指定位置。<br>但ADD支持将压缩包<strong>自动解压</strong>以及<strong>远程下载</strong>文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hello.txt /app/hello.txt</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> app.tar.gz /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/file.zip /tmp/</span><br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置镜像的环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_ENV=prod<br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>设置构建镜像时的默认参数，设置后无需在build时用命令行传入参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> APP_VERSION=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>设置当前工作路径，相当于<code>cd</code>。WORKDIR可以设置多次，既可以用相对路径也可以用绝对路径。若使用相对路径，则这个相对路径是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> src</span><br></code></pre></td></tr></table></figure><p>最终的工作路径是<code>/root/app/src</code>。</p><p>注意事项：</p><ul><li>若使用相对路径，则是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>RUN用于容器内部执行命令（如安装依赖、编译项目等）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br></code></pre></td></tr></table></figure><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>用来指定对外开放的端口及协议。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/udp<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>EXPOSE只会暴露端口，但不会完成宿主机端口到容器端口的映射，需要在镜像<strong>运行</strong>时使用<code>docker run -p 5000:5000 myapp</code>完成。</li></ul><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>指定容器的固定启动任务，一个Dockerfile只能有一个ENTRYPOINT。配合CMD命令使用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD用于指明容器运行任务的默认参数，或作为备用的主命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>ENTRYPOINT与CMD都只能有一个，如果写了多个只会最后一个生效。</li></ul><h1 id="使用Dockerfile构建Docker"><a href="#使用Dockerfile构建Docker" class="headerlink" title="使用Dockerfile构建Docker"></a>使用Dockerfile构建Docker</h1><ol><li>构造dockerfile</li><li>使用build命令打包docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t &lt;镜像名&gt;:&lt;标签&gt; &lt;构建上下文路径&gt;<br>docker build -t myapp:1.0 .<br></code></pre></td></tr></table></figure><p>其中参数-t用于给镜像命名。<br>3. 使用run命令启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run &lt;镜像名&gt; --name &lt;容器名&gt; -d<br></code></pre></td></tr></table></figure><p>其中-name用于指定容器名，-d表示后台运行。</p>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
