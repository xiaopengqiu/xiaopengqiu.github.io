<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2025/04/how-to-use-hexo/"/>
    <url>/2025/04/how-to-use-hexo/</url>
    
    <content type="html"><![CDATA[<p>介绍一下hexo使用过程中常用的指令。</p><span id="more"></span> <h1 id="如何使用hexo"><a href="#如何使用hexo" class="headerlink" title="如何使用hexo"></a>如何使用hexo</h1><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><ol><li>在默认目录source&#x2F;_post下创建文章。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post &lt;article name&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>在子目录下创建文章，使用-p参数，会在source&#x2F;_post下创建子目录dir。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post -p &lt;<span class="hljs-built_in">dir</span>/article name&gt;<br></code></pre></td></tr></table></figure><h2 id="创建草稿"><a href="#创建草稿" class="headerlink" title="创建草稿"></a>创建草稿</h2><ol><li>默认会在source&#x2F;_drafts目录下创建草稿。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new draft &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h2><ol><li>直接将草稿中的文件移动到默认目录source&#x2F;_post下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo publish &lt;draft name&gt;<br></code></pre></td></tr></table></figure><h2 id="设置摘要"><a href="#设置摘要" class="headerlink" title="设置摘要"></a>设置摘要</h2><p>在摘要内容末尾添加标注<code>&lt;!-- more --&gt;</code>，会将该标志前面部分设置为摘要，后面的为正文。</p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>需要把图片先存入文章的同名目录下，并使用asset_img命令在文章指定位置插入图片。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% asset_img 图片名称 图片标题 %&#125;<br></code></pre></td></tr></table></figure><h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><ol><li>在config文件中配置将hexo部署到github上，配置方法参考<a href="https://blog.csdn.net/yaorongke/article/details/119089190">文章</a>。</li><li>使用命令<code>hexo g -d</code>完成文章内容推送到GitHub上。g表示generate生成网页内容，d表示deploy部署，上述命令可以写成<code>hexo generate &amp;&amp; hexo deploy</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Docker</title>
    <link href="/2025/04/what-is-docker/"/>
    <url>/2025/04/what-is-docker/</url>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的轻量级容器平台，可以将应用及其依赖打包在Docker中，实现快速部署和跨环境运行。</p><span id="more"></span> <h1 id="Docker的核心组件"><a href="#Docker的核心组件" class="headerlink" title="Docker的核心组件"></a>Docker的核心组件</h1><p>Docker基于B&#x2F;S架构，其核心组件包括</p><ol><li>Docker Client</li><li>Docker Daemon</li><li>Docker Image</li><li>Docker Register</li><li>Docker Container</li></ol><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>用于发起各种请求，如<code>docker run</code>、<code>docker build</code>等等。最常用的 Docker 客户端就是 docker 命令和<a href="https://www.docker.com/products/docker-desktop/">docker desktop</a>。</p><h2 id="Dokcer-Deamon"><a href="#Dokcer-Deamon" class="headerlink" title="Dokcer Deamon"></a>Dokcer Deamon</h2><p>又称之为docker的核心进程，该进程会提供一个<strong>API Server</strong>（API Server是Deamon的一部分），负责接收来自docker client的请求，API Server 将通过Docker daemon 内部的一个<strong>路由</strong>分发调度，将请求路由到Daemon中对应的处理函数<strong>handler</strong>，handler再调用底层逻辑完成请求响应，并通过API Server返回响应。</p><p>Handler调用底层逻辑时，会交由处理引擎engine创建指定的job，job中绑定了具体的功能函数，完成处理逻辑。</p><p>Job 实际上是封装了对某个具体任务的调用。docker Daemon 启动时，会注册各种 Job：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/docker/docker/daemon/daemon.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> Install(eng *engine.Engine) <span class="hljs-type">error</span> &#123;<br>    eng.Register(<span class="hljs-string">&quot;create&quot;</span>, daemon.ContainerCreate)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler在运行时创建Job完成处理逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">job := eng.Job(<span class="hljs-string">&quot;create&quot;</span>, args...)<br><span class="hljs-keyword">if</span> err := job.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>docker deamon的结构可以分为三个部分：</p><ul><li>Docker Server，包括API Server、Router、Handler</li><li>Engine</li><li>Job</li></ul><p>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。 Docker Daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker Deamon的架构图如下所示：</p><img src="/2025/04/what-is-docker/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" class="" title="Docker架构图"><p>Job运行过程的作用有以下几种可能：</p><p>向 Docker Registry 获取镜像</p><ul><li>通过 graphdriver 执行容器镜像的本地化操作</li><li>通过 networkdriver 执行容器网络环境的配置</li><li>通过 execdriver 执行容器内部运行的执行工作</li></ul><h2 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h2><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</p><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 docker build &lt;docker-file&gt; 命令可以构建出 Docker 镜像。</p><h2 id="Docker-Register"><a href="#Docker-Register" class="headerlink" title="Docker Register"></a>Docker Register</h2><p>Docker registry 是存储 docker image 的仓库，运行docker push、docker pull、docker search时，实际上是通过 docker daemon 与 docker registry 通信。</p><h2 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h2><p>Container是Image运行的一个实例，是Image的运行时，是真正运行项目程序、消耗系统资源、提供服务的地方。</p><h1 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h1><p>Dockerfile是自动构建docker的配置文件，定义了docker image构建的流程。</p><h2 id="Dockerfile主要结构"><a href="#Dockerfile主要结构" class="headerlink" title="Dockerfile主要结构"></a>Dockerfile主要结构</h2><p>一般来说，一个dockerfile文件包含四个内容：</p><ol><li>基础镜像信息指令 FROM。</li><li>声明Image元信息（不只是创作者）的指令 LABEL.</li><li>镜像操作指令RUN 、 EVN 、 ADD 和 WORKDIR 等</li><li>镜像构建指令CMD 、 ENTRYPOINT 和 USER 等</li></ol><p>下面是一段简单的Dockerfile的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br><span class="hljs-keyword">MAINTAINER</span> qxp &lt;xiaopengqiu8@gmail.com&gt;<br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-comment"># 设置容器启动时执行的主程序为 python</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>] </span><br><span class="hljs-comment"># CMD 会作为参数传给 ENTRYPOINT，结合起来就是 python app.py</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>] </span><br></code></pre></td></tr></table></figure><h2 id="Dockerfile的常见命令"><a href="#Dockerfile的常见命令" class="headerlink" title="Dockerfile的常见命令"></a>Dockerfile的常见命令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>每个镜像都必须基于基础镜像构建，FROM 用于指定其父镜像。其中<code>FROM scratch</code>表示父镜像为空镜像，若不需要基于基础镜像构建，仍然需要用 FROM 进行指定。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br></code></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>用于指定镜像的元数据，使用Key-Value标签，支持设定多个元数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;Angel_Kitty &lt;angelkitty6698@gmail.com&gt;&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;A cool Python app&quot;</span></span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>多次定义相同的 key，后面的会覆盖前面的</li></ul><h3 id="COPY、ADD"><a href="#COPY、ADD" class="headerlink" title="COPY、ADD"></a>COPY、ADD</h3><p>这两个命令都是将<strong>本地主机文件</strong>复制到指定<strong>容器</strong>中指定位置。<br>但ADD支持将压缩包<strong>自动解压</strong>以及<strong>远程下载</strong>文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hello.txt /app/hello.txt</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> app.tar.gz /app/</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/file.zip /tmp/</span><br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置镜像的环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_ENV=prod<br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>设置构建镜像时的默认参数，设置后无需在build时用命令行传入参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> APP_VERSION=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>设置当前工作路径，相当于<code>cd</code>。WORKDIR可以设置多次，既可以用相对路径也可以用绝对路径。若使用相对路径，则这个相对路径是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> src</span><br></code></pre></td></tr></table></figure><p>最终的工作路径是<code>/root/app/src</code>。</p><p>注意事项：</p><ul><li>若使用相对路径，则是相对于上一个 WORKDIR 的路径，或者是默认根目录 <code>/</code>。</li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>RUN用于容器内部执行命令（如安装依赖、编译项目等）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br></code></pre></td></tr></table></figure><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>用来指定对外开放的端口及协议。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/udp<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>EXPOSE只会暴露端口，但不会完成宿主机端口到容器端口的映射，需要在镜像<strong>运行</strong>时使用<code>docker run -p 5000:5000 myapp</code>完成。</li></ul><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>指定容器的固定启动任务，一个Dockerfile只能有一个ENTRYPOINT。配合CMD命令使用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD用于指明容器运行任务的默认参数，或作为备用的主命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>ENTRYPOINT与CMD都只能有一个，如果写了多个只会最后一个生效。</li></ul><h1 id="使用Dockerfile构建Docker"><a href="#使用Dockerfile构建Docker" class="headerlink" title="使用Dockerfile构建Docker"></a>使用Dockerfile构建Docker</h1><ol><li>构造dockerfile</li><li>使用build命令打包docker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t &lt;镜像名&gt;:&lt;标签&gt; &lt;构建上下文路径&gt;<br>docker build -t myapp:1.0 .<br></code></pre></td></tr></table></figure><p>其中参数-t用于给镜像命名。<br>3. 使用run命令启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run &lt;镜像名&gt; --name &lt;容器名&gt; -d<br></code></pre></td></tr></table></figure><p>其中-name用于指定容器名，-d表示后台运行。</p><h1 id="容器是怎么隔离的"><a href="#容器是怎么隔离的" class="headerlink" title="容器是怎么隔离的"></a>容器是怎么隔离的</h1><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创建一个“边界”。</p><p>容器技术里进行隔离的两个核心技术：<strong>Cgroup</strong>技术和<strong>Namespace</strong>技术。</p><h2 id="Cgroup技术"><a href="#Cgroup技术" class="headerlink" title="Cgroup技术"></a>Cgroup技术</h2><p>其名源自<strong>控制组群（Control Group）<strong>的简写，是Linux内核的一个功能，通过</strong>追踪和限制</strong>进程组的资源使用情况，来限制、控制与分离一个<strong>进程组</strong>的资源（如CPU、内存、磁盘等）。</p><h2 id="Namespace技术"><a href="#Namespace技术" class="headerlink" title="Namespace技术"></a>Namespace技术</h2><p>Namespace是Linux内核的一种机制，通过在内核中为不同进程分配不同的<strong>资源视图</strong>来实现资源隔离。</p><p>通俗的来讲，Cgroup负责<strong>资源限制</strong>，限制容器能使用多少资源；Namespace负责<strong>资源隔离</strong>，让容器看不见“外面的世界”。</p><h1 id="Docker的镜像层"><a href="#Docker的镜像层" class="headerlink" title="Docker的镜像层"></a>Docker的镜像层</h1><p>Docker镜像实际上不是一个完整的压缩包，而是由一层层镜像层叠加而成的结构，每一层都是一个文件系统的变更记录，最终形成完整的可用镜像。</p><p>镜像层由Dockerfile中的<strong>每一条指令</strong>生成，比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span>        <span class="hljs-comment"># 创建基础层（Layer 1）</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update       <span class="hljs-comment"># 创建新的只读层（Layer 2）</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y python3 <span class="hljs-comment"># Layer 3</span></span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app              <span class="hljs-comment"># Layer 4</span></span><br></code></pre></td></tr></table></figure><p>镜像层的特点：</p><ul><li>每执行一条指令，就会生成一层</li><li>每一层都依赖于上一层</li><li>每一层都是不可变的，都是<strong>只读层</strong></li><li>如果中间的镜像层发生变化，Docker就会重建该层及以上的层。</li></ul><p>每一个镜像层本质上是一个文件快照系统（通常是一个.tar压缩包），它记录了该层：</p><ul><li>添加的文件</li><li>修改的文件</li><li>删除的文件</li></ul><p>使用镜像层的好处：</p><ol><li>分层缓存<br>Docker构建镜像时，如果某层的指令没变，它就会复用该层，避免重新构建。</li><li>高效存储<br>多个镜像可以共用相同的底层层（比如多个 Python 项目共用 ubuntu 基础层），节省磁盘空间。</li><li>快速分发<br>每一层都可以单独下载和上传，Docker Hub只需要同步变化的部分。</li></ol><h1 id="Docker的容器层"><a href="#Docker的容器层" class="headerlink" title="Docker的容器层"></a>Docker的容器层</h1><p>基于镜像构建容器时，就是在最外层增加一个<strong>可写层</strong>供动态编辑。<br>容器层主要负责：</p><ul><li>容器运行时的文件写入（如生成日志、缓存文件、应用运行时的临时数据）；</li><li>用户在容器内修改文件（如 echo hello &gt; file.txt）；<br>容器停止或删除，可写层会消失。若使用 <code>docker commit</code>将容器保存成新的镜像，就会把可写层也转化成镜像层。</li></ul><p>注意事项：</p><ul><li>Cgroup和Namespace都属于内核空间，与层无关，由进程加载对应的配置；镜像层、容器层都属于文件系统。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生资源类型</title>
    <link href="/2025/06/what-is-workload/"/>
    <url>/2025/06/what-is-workload/</url>
    
    <content type="html"><![CDATA[<p>云原生资源类型：</p><ul><li>工作负载（Workload）资源</li><li>服务发现与负载均衡资源（Service &amp; Networking）</li><li>配置与存储资源（Configuration &amp; Storage）</li><li>身份与访问控制（Security &amp; RBAC）</li><li>调度与运行时资源（Scheduling &amp; Runtime）</li><li>集群元数据与控制资源（Meta &amp; Control）</li></ul><h2 id="workload"><a href="#workload" class="headerlink" title="workload"></a>workload</h2><p>workload是指运行在k8s集群上的应用程序实例，workload通常管理着一组Pod。</p><p>常见的 Workload 类型（以 Kubernetes 为例）：</p><ol><li><p>Pod<br>最基本的计算单元，通常包含一个或多个容器。</p></li><li><p>Deployment<br>用于管理无状态服务，支持自动扩缩容、滚动更新等。</p></li><li><p>StatefulSet<br>用于管理有状态服务，比如数据库，提供稳定的网络标识、存储等。</p></li><li><p>DaemonSet<br>保证每个（或指定）节点上运行一个 Pod，常用于日志收集、监控等。</p></li><li><p>Job<br>一次性任务，执行完成后退出，适用于批处理任务。</p></li><li><p>CronJob<br>类似于 Linux 的定时任务，定时运行 Job。</p></li></ol><p>Workload 的作用</p><ul><li><p>部署应用：你可以通过定义 Deployment 或 StatefulSet 来部署服务。</p></li><li><p>生命周期管理：自动控制副本数量、重启策略、滚动升级等。</p></li><li><p>解耦基础设施与应用：Workload 资源定义了“运行什么、怎么运行”，与底层节点、操作系统解耦。</p></li><li><p>可观测性和伸缩性：配合服务网格、监控工具和自动扩缩容机制，提高系统弹性。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
